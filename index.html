<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Geometry Dash</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #f0f0f0;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #fff;
    box-shadow: 0 0 10px #aaa;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const GROUND_Y = canvas.height - 20;

  // Player config
  const PLAYER_SIZE = 30;
  const GRAVITY = 1;

  // Jump parameters
  let jumpForce = -20; // start jump force
  const JUMP_DECREASE_STEP = 0.5;
  const JUMP_DECREASE_SCORE_INTERVAL = 1500;
  const JUMP_MIN_FORCE = -18;
  const JUMP_INITIAL_DECREASE_LIMIT = 2500;

  // Game state
  let player, obstacles, scrollSpeed, score, highScore, gameOver, youWin;
  let obstacleTimer = 0;
  let obstacleInterval = 90;

  // Pattern setup
  let patternIndex = 0;
  const patterns = [
    // each pattern is an array of obstacles (type and count) and spacing
    [{type:'spike', count:1, spacing: 35}],
    [{type:'spike', count:2, spacing: 40}],
    [{type:'block', count:1, spacing: 35}],
    [{type:'block', count:2, spacing: 40}],
    [{type:'platform', count:1, spacing: 80}],  // safe platform
    [{type:'spike', count:3, spacing: 35}], // only after score 4000
  ];

  function initGame() {
    player = {
      x: 100,
      y: GROUND_Y - PLAYER_SIZE,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      velocityY: 0,
      onGround: true,
    };

    obstacles = [];
    scrollSpeed = 5;
    score = 0;
    gameOver = false;
    youWin = false;
    obstacleTimer = 0;
    obstacleInterval = 90;
    jumpForce = -20;
    patternIndex = 0;

    highScore = parseInt(localStorage.getItem('gdHighScore')) || 0;

    // Spawn initial obstacles so screen isn't empty
    let startX = canvas.width + 50;
    for(let i=0; i<5; i++){
      addPattern(startX);
      startX += 220; // base spacing between patterns
    }
  }

  function addPattern(startX){
    // control pattern choice so 3 spikes only after score >=4000
    let availablePatterns = patterns.slice(0, 5);
    if(score >= 4000) availablePatterns.push(patterns[5]);

    let pattern = availablePatterns[patternIndex % availablePatterns.length];
    patternIndex++;

    for(let i=0; i<pattern.length; i++){
      const pat = pattern[i];
      for(let c=0; c<pat.count; c++){
        // Check no obstacle already too close to this spawn x to avoid overlap
        let spawnX = startX + c * pat.spacing;
        if(obstacles.some(o => Math.abs(o.x - spawnX) < 30)){
          // if too close, shift this spawnX forward by 40 pixels
          spawnX += 40;
        }
        obstacles.push({
          x: spawnX,
          y: GROUND_Y,
          width: 30,
          height: 30,
          type: pat.type
        });
      }
      startX += (pat.count * pat.spacing) + 100; // add spacing between groups in pattern
    }
  }

  function drawSpike(x, y, size) {
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + size / 2, y - size);
    ctx.lineTo(x + size, y);
    ctx.closePath();
    ctx.fill();
  }

  function drawBlock(x, y, size) {
    ctx.fillStyle = '#c0392b';
    ctx.fillRect(x, y - size, size, size);
  }

  function drawPlatform(x, y, size) {
    ctx.fillStyle = '#3498db'; // blue platform
    ctx.fillRect(x, y - size, size, size / 4); // thin platform
  }

  // Collision with platform: safe on top, death on side or bottom
  function checkCollision(player, ob){
    if(ob.type === 'block'){
      // Full rectangle collision
      return !(player.x + player.width < ob.x ||
               player.x > ob.x + ob.width ||
               player.y + player.height < ob.y - ob.height ||
               player.y > ob.y);
    }
    else if(ob.type === 'spike'){
      // Spike hitbox adjusted rectangle
      const spikeTop = ob.y - ob.height;
      return !(player.x + player.width < ob.x ||
               player.x > ob.x + ob.width ||
               player.y + player.height < spikeTop ||
               player.y > ob.y);
    }
    else if(ob.type === 'platform'){
      const platformTop = ob.y - ob.height / 4; // platform height is height/4
      const platformLeft = ob.x;
      const platformRight = ob.x + ob.width;
      const platformBottom = ob.y;

      const playerBottom = player.y + player.height;
      const playerTop = player.y;
      const playerRight = player.x + player.width;
      const playerLeft = player.x;

      const onTop = playerBottom >= platformTop - 2 && playerBottom <= platformTop + 5;
      const withinX = playerRight > platformLeft + 5 && playerLeft < platformRight - 5;
      const falling = player.velocityY >= 0;

      if(onTop && withinX && falling){
        // Landed safely on top
        player.y = platformTop - player.height;
        player.velocityY = 0;
        player.onGround = true;
        return false; // no death
      }

      // Check if player hits sides or bottom of platform
      const hitLeftSide = playerRight > platformLeft && playerLeft < platformLeft && playerBottom > platformTop;
      const hitRightSide = playerLeft < platformRight && playerRight > platformRight && playerBottom > platformTop;
      const hitBottom = playerTop < platformBottom && playerBottom > platformBottom && playerRight > platformLeft && playerLeft < platformRight;

      if(hitLeftSide || hitRightSide || hitBottom){
        // Colliding with platform side or bottom = death
        return true;
      }

      return false; // no collision
    }
    return false;
  }

  function update() {
    if(gameOver || youWin) return;

    // Win check
    if(score >= 10000){
      youWin = true;
      gameOver = true;
      return;
    }

    // Adjust jump force as score increases
    if(score < JUMP_INITIAL_DECREASE_LIMIT){
      jumpForce = -20;
    } else {
      let stepsPassed = Math.floor((score - JUMP_INITIAL_DECREASE_LIMIT) / JUMP_DECREASE_SCORE_INTERVAL);
      jumpForce = Math.max(-20 + stepsPassed * JUMP_DECREASE_STEP, JUMP_MIN_FORCE);
    }

    player.velocityY += GRAVITY;
    player.y += player.velocityY;

    // Ground collision
    if(player.y + player.height >= GROUND_Y){
      player.y = GROUND_Y - player.height;
      player.velocityY = 0;
      player.onGround = true;
    }

    // Move obstacles and check collisions
    for(let i = obstacles.length - 1; i >= 0; i--){
      const ob = obstacles[i];
      ob.x -= scrollSpeed;

      if(checkCollision(player, ob)){
        if(ob.type === 'spike' || ob.type === 'block' || ob.type === 'platform'){
          gameOver = true;
          if(score > highScore){
            highScore = score;
            localStorage.setItem('gdHighScore', highScore);
          }
        }
      }

      if(ob.x + ob.width < 0){
        obstacles.splice(i, 1);
      }
    }

    // Add obstacles at intervals
    obstacleTimer++;
    if(obstacleTimer > obstacleInterval){
      obstacleTimer = 0;
      addPattern(canvas.width + 10);
      scrollSpeed += 0.05;
      if(obstacleInterval > 45) obstacleInterval -= 1;
    }

    score++;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#95a5a6';
    ctx.fillRect(0, GROUND_Y, canvas.width, 20);

    // Player
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Obstacles
    for(const ob of obstacles){
      if(ob.type === 'spike'){
        drawSpike(ob.x, ob.y, ob.width);
      } else if(ob.type === 'block'){
        drawBlock(ob.x, ob.y, ob.width);
      } else if(ob.type === 'platform'){
        drawPlatform(ob.x, ob.y, ob.width);
      }
    }

    // Score & High Score
    ctx.fillStyle = '#2c3e50';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 30);
    ctx.fillText(`High Score: ${highScore}`, 10, 60);

    if(gameOver && !youWin){
      ctx.fillStyle = '#e74c3c';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Press Space or Up to Restart', canvas.width / 2, canvas.height / 2 + 20);
    }

    if(youWin){
      const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 200);
      ctx.fillStyle = `rgba(46, 204, 113, ${alpha})`; // green flashing
      ctx.font = '50px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You Win!', canvas.width / 2, canvas.height / 2);
    }
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('keydown', e => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      if(!gameOver && player.onGround){
        player.velocityY = jumpForce;
        player.onGround = false;
      } else if(gameOver){
        initGame();
      }
    }
  });

  initGame();
  loop();
})();
</script>
</body>
</html>
