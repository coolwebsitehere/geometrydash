<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Geometry Dash Inspired Endless Runner</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #f0f0f0;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #fff;
    box-shadow: 0 0 10px #aaa;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const GROUND_Y = canvas.height - 20;

  // Player config
  const PLAYER_SIZE = 30;
  const GRAVITY = 1;
  const JUMP_FORCE = -16; // slightly stronger jump

  // Game state
  let player, obstacles, scrollSpeed, score, highScore, gameOver;
  let patternIndex = 0;

  // Predefined pattern sequence of 10 obstacle sets
  // Each pattern is an object: { type: 'spike'|'block'|'gap', count: number, gapAfter: number }
  // gapAfter is space after the pattern to next one, in pixels
  const patternSequence = [
    { type: 'spike', count: 1, gapAfter: 180 },
    { type: 'gap', count: 0, gapAfter: 220 },
    { type: 'block', count: 1, gapAfter: 200 },
    { type: 'spike', count: 2, gapAfter: 240 },
    { type: 'gap', count: 0, gapAfter: 200 },
    { type: 'block', count: 2, gapAfter: 260 },
    { type: 'spike', count: 1, gapAfter: 180 },
    { type: 'gap', count: 0, gapAfter: 220 },
    { type: 'block', count: 1, gapAfter: 200 },
    { type: 'spike', count: 3, gapAfter: 280 },
  ];

  function initGame() {
    player = {
      x: 100,
      y: GROUND_Y - PLAYER_SIZE,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      velocityY: 0,
      onGround: true,
    };

    obstacles = [];
    scrollSpeed = 5;
    score = 0;
    gameOver = false;
    patternIndex = 0;
    highScore = parseInt(localStorage.getItem('gdHighScore')) || 0;

    // Spawn initial patterns to fill screen
    let startX = canvas.width + 50;
    for(let i=0; i<5; i++){
      startX = addPattern(startX);
    }
  }

  // Add the next pattern from sequence at startX, returns new X position after adding obstacles + gap
  function addPattern(startX){
    const pattern = patternSequence[patternIndex];
    patternIndex = (patternIndex + 1) % patternSequence.length;

    if(pattern.type === 'gap'){
      // Just a gap, no obstacles
      return startX + pattern.gapAfter;
    }

    for(let i=0; i<pattern.count; i++){
      obstacles.push({
        x: startX + i * 35,
        y: GROUND_Y,
        width: 30,
        height: 30,
        type: pattern.type,
      });
    }

    return startX + pattern.count * 35 + pattern.gapAfter;
  }

  function drawSpike(x, y, size) {
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + size / 2, y - size);
    ctx.lineTo(x + size, y);
    ctx.closePath();
    ctx.fill();
  }

  function drawBlock(x, y, size) {
    ctx.fillStyle = '#c0392b';
    ctx.fillRect(x, y - size, size, size);
  }

  function checkCollision(player, ob){
    if(ob.type === 'block'){
      return !(player.x + player.width < ob.x ||
               player.x > ob.x + ob.width ||
               player.y + player.height < ob.y - ob.height ||
               player.y > ob.y);
    }
    else if(ob.type === 'spike'){
      const spikeTop = ob.y - ob.height;
      return !(player.x + player.width < ob.x ||
               player.x > ob.x + ob.width ||
               player.y + player.height < spikeTop ||
               player.y > ob.y);
    }
    return false;
  }

  function update() {
    if (gameOver) return;

    player.velocityY += GRAVITY;
    player.y += player.velocityY;

    if (player.y + player.height >= GROUND_Y) {
      player.y = GROUND_Y - player.height;
      player.velocityY = 0;
      player.onGround = true;
    }

    // Move obstacles and check collisions
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const ob = obstacles[i];
      ob.x -= scrollSpeed;

      if (checkCollision(player, ob)) {
        gameOver = true;
        if(score > highScore){
          highScore = score;
          localStorage.setItem('gdHighScore', highScore);
        }
      }

      if (ob.x + ob.width < 0) {
        obstacles.splice(i, 1);
      }
    }

    // Add patterns when last obstacle is nearing screen edge
    if(obstacles.length === 0){
      // No obstacles yet? Spawn some
      let startX = canvas.width + 50;
      for(let i=0; i<3; i++){
        startX = addPattern(startX);
      }
    } else {
      const lastObstacle = obstacles[obstacles.length - 1];
      if(lastObstacle.x < canvas.width - 300){
        // Add next pattern when last obstacle is far enough left
        let newStartX = lastObstacle.x + 150;
        addPattern(newStartX);
      }
    }

    // Increase speed every 500 points slightly
    if(score > 0 && score % 500 === 0){
      scrollSpeed = Math.min(scrollSpeed + 0.2, 12);
    }

    score++;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#95a5a6';
    ctx.fillRect(0, GROUND_Y, canvas.width, 20);

    // Player
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Obstacles
    for (const ob of obstacles) {
      if (ob.type === 'spike') {
        drawSpike(ob.x, ob.y, ob.width);
      } else {
        drawBlock(ob.x, ob.y, ob.width);
      }
    }

    // Score & High Score
    ctx.fillStyle = '#2c3e50';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 30);
    ctx.fillText(`High Score: ${highScore}`, 10, 60);

    if (gameOver) {
      ctx.fillStyle = '#e74c3c';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Press Space or Up to Restart', canvas.width / 2, canvas.height / 2 + 20);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      if (!gameOver && player.onGround) {
        player.velocityY = JUMP_FORCE;
        player.onGround = false;
      } else if (gameOver) {
        initGame();
      }
    }
  });

  initGame();
  loop();
})();
</script>
</body>
</html>
