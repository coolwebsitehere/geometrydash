<!DOCTYPE html>
<html>
<head>
<title>Geometry Dash</title>
<style>
  body {
    margin: 0;
    background: #222;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #111;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let player = {
  x: 50,
  y: canvas.height - 60,
  width: 40,
  height: 40,
  dy: 0,
  gravity: 0.8,
  jumpPower: -18, // slightly lower jump
  grounded: false
};

let obstacles = [];
let platforms = [];
let score = 0;
let highScore = localStorage.getItem("highScore") || 0;
let gameOver = false;
let scrollSpeed = 6; // starts faster than before

function jump() {
  if (player.grounded) {
    player.dy = player.jumpPower;
    player.grounded = false;
  }
}

document.addEventListener("keydown", e => {
  if ((e.code === "Space" || e.code === "ArrowUp") && !gameOver) {
    jump();
  }
  if (gameOver && e.code === "Enter") resetGame();
});

// Mouse click also jumps
document.addEventListener("mousedown", () => {
  if (!gameOver) {
    jump();
  } else {
    resetGame();
  }
});

function resetGame() {
  obstacles = [];
  platforms = [];
  score = 0;
  scrollSpeed = 6;
  player.y = canvas.height - 60;
  player.dy = 0;
  player.grounded = false;
  gameOver = false;
}

function spawnObstacle() {
  let height = 40;
  let type = Math.random() < 0.5 ? "spike" : "block";
  let obs = {
    x: canvas.width,
    y: canvas.height - height,
    width: type === "spike" ? 40 : 40,
    height: height,
    type: type
  };
  obstacles.push(obs);
}

function spawnPlatform() {
  let platWidth = 100;
  let platHeight = 20;
  let platY = canvas.height - 150;
  let plat = {
    x: canvas.width,
    y: platY,
    width: platWidth,
    height: platHeight
  };
  platforms.push(plat);
}

let obstacleTimer = 0;
let platformTimer = 0;

function update() {
  if (gameOver) return;

  player.dy += player.gravity;
  player.y += player.dy;

  // Ground collision
  if (player.y + player.height >= canvas.height) {
    player.y = canvas.height - player.height;
    player.dy = 0;
    player.grounded = true;
  }

  // Move & remove obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    let obs = obstacles[i];
    obs.x -= scrollSpeed;

    // Spike collision
    if (obs.type === "spike" && checkCollision(player, obs)) {
      gameOver = true;
    }

    // Block collision
    if (obs.type === "block" && checkCollision(player, obs)) {
      gameOver = true;
    }

    if (obs.x + obs.width < 0) {
      obstacles.splice(i, 1);
    }
  }

  // Platforms
  for (let i = platforms.length - 1; i >= 0; i--) {
    let p = platforms[i];
    p.x -= scrollSpeed;

    // Only collide on top
    if (player.dy >= 0 &&
        player.x < p.x + p.width &&
        player.x + player.width > p.x &&
        player.y + player.height <= p.y + 10 &&
        player.y + player.height >= p.y - 10) {
      player.y = p.y - player.height;
      player.dy = 0;
      player.grounded = true;
    }

    // Side collision = death
    if (checkCollision(player, p) &&
        !(player.y + player.height <= p.y)) {
      gameOver = true;
    }

    if (p.x + p.width < 0) {
      platforms.splice(i, 1);
    }
  }

  obstacleTimer++;
  platformTimer++;

  // Random obstacle spawn
  if (obstacleTimer > 60 + Math.random() * 40) {
    spawnObstacle();
    obstacleTimer = 0;
  }

  // Random platform spawn
  if (platformTimer > 200 + Math.random() * 200) {
    spawnPlatform();
    platformTimer = 0;
  }

  // Increase difficulty
  if (score > 0 && score % 500 === 0) {
    scrollSpeed = Math.min(scrollSpeed + 0.2, 12);
  }

  score++;

  if (score > highScore) {
    highScore = score;
    localStorage.setItem("highScore", highScore);
  }
}

function checkCollision(a, b) {
  return a.x < b.x + b.width &&
         a.x + a.width > b.x &&
         a.y < b.y + b.height &&
         a.y + a.height > b.y;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Player
  ctx.fillStyle = "yellow";
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Obstacles
  obstacles.forEach(obs => {
    ctx.fillStyle = obs.type === "spike" ? "red" : "purple";
    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
  });

  // Platforms
  ctx.fillStyle = "blue";
  platforms.forEach(p => {
    ctx.fillRect(p.x, p.y, p.width, p.height);
  });

  // Score
  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 10, 20);
  ctx.fillText("High Score: " + highScore, 10, 40);

  if (gameOver) {
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.fillText("Game Over!", canvas.width / 2 - 100, canvas.height / 2);
    ctx.font = "20px Arial";
    ctx.fillText("Press Enter or Click to Restart", canvas.width / 2 - 140, canvas.height / 2 + 40);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
