<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Geometry Dash</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: white;
    transition: background 0.4s ease;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Themes for background, player, obstacle colors
  const themes = [
    { bg: '#ffffff', player: '#000000', obstacle: '#ff0000' },
    { bg: '#cce7ff', player: '#003344', obstacle: '#cc4400' },
    { bg: '#ffe6cc', player: '#663300', obstacle: '#004466' },
    { bg: '#e0ffcc', player: '#334400', obstacle: '#660033' },
    { bg: '#ffd6d6', player: '#990000', obstacle: '#000066' },
    { bg: '#f0e6ff', player: '#3a0066', obstacle: '#00663a' },
  ];

  let currentThemeIndex = 0;

  // Game constants
  const GROUND_Y = canvas.height - 20;
  const PLAYER_SIZE = 30;
  const GRAVITY = 1;
  const JUMP_INITIAL_FORCE = -18;
  const JUMP_DECREASE_STEP = 0.5;
  const JUMP_DECREASE_SCORE_INTERVAL = 1500;
  const JUMP_MIN_FORCE = -15;
  const JUMP_INITIAL_DECREASE_LIMIT = 2500;
  const OBSTACLE_INTERVAL_START = 120;
  const OBSTACLE_INTERVAL_MIN = 45;
  const SPEED_INCREMENT = 0.05;
  const SPEED_START = 6;

  // Game state variables
  let player, obstacles, scrollSpeed, score, highScore, gameOver, youWin;
  let obstacleTimer = 0;
  let obstacleInterval = OBSTACLE_INTERVAL_START;
  let jumpForce = JUMP_INITIAL_FORCE;
  let rotationAngle = 0;

  // Patterns with spacing: no two blocks side-by-side
  // spacing ensures obstacles don't overlap or cluster too much
  const patterns = [
    [{type:'spike', count:1, spacing: 120}],
    [{type:'spike', count:3, spacing: 60}],
    [{type:'spike', count:1, spacing: 90}, {type:'block', count:1, spacing: 120}],
    [{type:'spike', count:2, spacing: 90}],
    [{type:'block', count:1, spacing: 150}],
  ];

  function initGame() {
    player = {
      x: 100,
      y: GROUND_Y - PLAYER_SIZE,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      velocityY: 0,
      onGround: true,
      rotation: 0,
    };

    obstacles = [];
    scrollSpeed = SPEED_START;
    score = 0;
    gameOver = false;
    youWin = false;
    obstacleTimer = 0;
    obstacleInterval = OBSTACLE_INTERVAL_START;
    jumpForce = JUMP_INITIAL_FORCE;
    rotationAngle = 0;

    highScore = parseInt(localStorage.getItem('gdHighScore')) || 0;

    // Start with first theme
    currentThemeIndex = 0;
    applyTheme(currentThemeIndex);

    // Spawn initial obstacles spaced well
    let startX = canvas.width + 100;
    for(let i = 0; i < 5; i++) {
      addPattern(startX);
      startX += 320; // bigger gap between initial obstacles
    }
  }

  // Add pattern obstacles starting at startX
  function addPattern(startX){
    const pattern = patterns[score < 4000 ? score % patterns.length : (score % patterns.length)]; 
    // Using modulo to loop patterns; can be improved if desired

    let currentX = startX;

    for(const pat of pattern){
      for(let c = 0; c < pat.count; c++){
        obstacles.push({
          x: currentX,
          y: GROUND_Y,
          width: 30,
          height: 30,
          type: pat.type,
        });
        currentX += pat.spacing;
      }
      currentX += 120; // extra space after pattern group
    }
  }

  function applyTheme(index){
    const theme = themes[index];
    canvas.style.background = theme.bg;
    player.color = theme.player;
    obstacleColor = theme.obstacle;
  }

  function checkCollision(player, ob){
    return !(
      player.x + player.width < ob.x ||
      player.x > ob.x + ob.width ||
      player.y + player.height < ob.y - ob.height ||
      player.y > ob.y
    );
  }

  function update() {
    if(gameOver || youWin) return;

    if(score >= 10000){
      youWin = true;
      gameOver = true;
      return;
    }

    // Jump force decreases slowly over time but capped
    if(score < JUMP_INITIAL_DECREASE_LIMIT){
      jumpForce = JUMP_INITIAL_FORCE;
    } else {
      let stepsPassed = Math.floor((score - JUMP_INITIAL_DECREASE_LIMIT) / JUMP_DECREASE_SCORE_INTERVAL);
      jumpForce = Math.max(JUMP_INITIAL_FORCE + stepsPassed * JUMP_DECREASE_STEP, JUMP_MIN_FORCE);
    }

    player.velocityY += GRAVITY;
    player.y += player.velocityY;

    if(player.y + player.height >= GROUND_Y){
      player.y = GROUND_Y - player.height;
      player.velocityY = 0;
      player.onGround = true;
    }

    // Move obstacles left and check collisions
    for(let i = obstacles.length - 1; i >= 0; i--){
      const ob = obstacles[i];
      ob.x -= scrollSpeed;

      if(checkCollision(player, ob)){
        gameOver = true;
        if(score > highScore){
          highScore = score;
          localStorage.setItem('gdHighScore', highScore);
        }
      }

      if(ob.x + ob.width < 0){
        obstacles.splice(i, 1);
      }
    }

    obstacleTimer++;
    if(obstacleTimer > obstacleInterval){
      obstacleTimer = 0;
      addPattern(canvas.width + 50);
      scrollSpeed += SPEED_INCREMENT;
      if(obstacleInterval > OBSTACLE_INTERVAL_MIN) obstacleInterval -= 1;
    }

    score++;

    // Change theme every 100 points
    if(score % 100 === 0){
      currentThemeIndex = (currentThemeIndex + 1) % themes.length;
      applyTheme(currentThemeIndex);
    }
  }

  function drawSpike(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + size / 2, y - size);
    ctx.lineTo(x + size, y);
    ctx.closePath();
    ctx.fill();
  }

  function drawBlock(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y - size, size, size);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#444';
    ctx.fillRect(0, GROUND_Y, canvas.width, 20);

    // Player with rotation
    ctx.save();
    ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
    ctx.rotate(player.rotation);
    ctx.fillStyle = player.color;
    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
    ctx.restore();

    // Draw obstacles
    for(const ob of obstacles){
      if(ob.type === 'spike'){
        drawSpike(ob.x, ob.y, ob.width, obstacleColor);
      } else if(ob.type === 'block'){
        drawBlock(ob.x, ob.y, ob.width, obstacleColor);
      }
    }

    // Scores
    ctx.fillStyle = player.color;
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 30);
    ctx.fillText(`High Score: ${highScore}`, 10, 60);

    // Game over
    if(gameOver && !youWin){
      ctx.fillStyle = '#e74c3c';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Press Space, Up or Click to Restart', canvas.width / 2, canvas.height / 2 + 20);
    }

    // Win message
    if(youWin){
      const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 200);
      ctx.fillStyle = `rgba(46, 204, 113, ${alpha})`;
      ctx.font = '50px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You Win!', canvas.width / 2, canvas.height / 2);
    }
  }

  function jump(){
    if(!gameOver && player.onGround){
      player.velocityY = jumpForce;
      player.onGround = false;
      rotationAngle += Math.PI / 2; // 90 deg rotation
      player.rotation = rotationAngle;
    } else if(gameOver){
      initGame();
    }
  }

  window.addEventListener('keydown', e => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      jump();
    }
  });

  window.addEventListener('mousedown', () => {
    jump();
  });

  initGame();

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
